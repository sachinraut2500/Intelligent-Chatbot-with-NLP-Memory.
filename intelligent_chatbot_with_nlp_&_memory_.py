# -*- coding: utf-8 -*-
"""Intelligent Chatbot with NLP & Memory.

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o3OR4VeCzokBLLmhDBl_dThg6i_3XQrR
"""

"""
Intelligent Chatbot with NLP & Memory
-------------------------------------

Features:
- Natural Language Understanding using spaCy
- Intent classification with scikit-learn (Naive Bayes)
- FAQ-style question answering from CSV/JSON knowledge base
- Contextual memory: chatbot remembers previous turns in a session
- Simple command-line interface (CLI)

Usage:
    # Train intent classifier
    python chatbot.py train --data intents.json --model chatbot_model.joblib

    # Run chatbot CLI
    python chatbot.py chat --model chatbot_model.joblib --kb faq.json

Dependencies:
    pip install spacy scikit-learn pandas joblib
    python -m spacy download en_core_web_sm
"""

import argparse
import json
import sys
from typing import Dict, Any, List
import pandas as pd
import spacy
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.naive_bayes import MultinomialNB
from sklearn.pipeline import Pipeline
import joblib


# -------------------------
# Intent Classifier
# -------------------------

def load_intents(path: str) -> pd.DataFrame:
    """Load intents JSON: {"intents": [{"tag": "greeting", "patterns": ["hi", "hello"], "responses": ["Hello!"]}]}"""
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)
    rows = []
    for intent in data.get("intents", []):
        tag = intent["tag"]
        for p in intent.get("patterns", []):
            rows.append({"text": p, "tag": tag})
    return pd.DataFrame(rows)


def train_intent_classifier(data_path: str, out_model: str):
    df = load_intents(data_path)
    X, y = df["text"], df["tag"]
    pipe = Pipeline([
        ("tfidf", TfidfVectorizer()),
        ("clf", MultinomialNB())
    ])
    pipe.fit(X, y)
    joblib.dump(pipe, out_model)
    print(f"âœ… Trained intent classifier saved to {out_model}")


# -------------------------
# FAQ Knowledge Base
# -------------------------

def load_kb(path: str) -> Dict[str, str]:
    """Load FAQ from JSON or CSV"""
    if path.endswith(".json"):
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    elif path.endswith(".csv"):
        df = pd.read_csv(path)
        return dict(zip(df["question"], df["answer"]))
    else:
        raise ValueError("Knowledge base must be .json or .csv")


# -------------------------
# Chatbot Engine
# -------------------------

class Chatbot:
    def __init__(self, model_path: str, kb_path: str):
        self.pipe = joblib.load(model_path)
        self.kb = load_kb(kb_path)
        self.memory: List[str] = []
        self.nlp = spacy.load("en_core_web_sm")

    def predict_intent(self, text: str) -> str:
        return self.pipe.predict([text])[0]

    def get_response(self, text: str) -> str:
        intent = self.predict_intent(text)

        # Greeting
        if intent == "greeting":
            return "Hello! How can I help you today?"

        # Farewell
        if intent == "goodbye":
            return "Goodbye! Have a great day!"

        # FAQ Matching (semantic with spaCy)
        doc = self.nlp(text.lower())
        best_q, best_sim = None, 0.0
        for q, a in self.kb.items():
            sim = doc.similarity(self.nlp(q.lower()))
            if sim > best_sim:
                best_q, best_sim = q, sim
        if best_sim > 0.6:
            return self.kb[best_q]

        # Context fallback
        if "price" in text.lower() and any("product" in m for m in self.memory):
            return "The price is $49.99."

        return "I'm not sure I understand. Can you rephrase?"

    def chat(self):
        print("ðŸ¤– Chatbot ready! (type 'quit' to exit)")
        while True:
            try:
                text = input("You: ").strip()
            except EOFError:
                break
            if text.lower() in {"quit", "exit"}:
                print("Bot: Goodbye!")
                break
            self.memory.append(text)
            response = self.get_response(text)
            print(f"Bot: {response}")


# -------------------------
# CLI
# -------------------------

def parse_args():
    p = argparse.ArgumentParser(description="Intelligent Chatbot with NLP & Memory")
    sub = p.add_subparsers(dest="command")

    t = sub.add_parser("train")
    t.add_argument("--data", required=True, help="Intents JSON file")
    t.add_argument("--model", required=True, help="Output model path")

    c = sub.add_parser("chat")
    c.add_argument("--model", required=True, help="Trained model path")
    c.add_argument("--kb", required=True, help="Knowledge base (json/csv)")

    return p.parse_args()


def main():
    args = parse_args()
    if args.command == "train":
        train_intent_classifier(args.data, args.model)
    elif args.command == "chat":
        bot = Chatbot(args.model, args.kb)
        bot.chat()
    else:
        print("No command given. Use --help.", file=sys.stderr)


if __name__ == "__main__":
    main()